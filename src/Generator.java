import java.util.ArrayList;
import java.util.Random;
import enums.*;

public class Generator {
	private static Random rand = new Random();
  /** The type of generation pattern. */
	static GenFx fx = GenFx.RADIAL;
	/** The number of points generated by {@code generateProblem()}. */
	public static int N = 0;
	/** Generator will generate graphs at approximately this density. */
	static double density = 0.1;
	
	/**
	 * Generates points on canvas in a radial, rectangular,
	 * or circular pattern. If solving minimum vertex cover,
	 * also adds edges to create a graph. Restricted to 
	 * screen size when in visual mode.
	 */
	public static void generateProblem() {
		Core.prob.unsolve();
		ArrayList<Point> dest = Core.prob.getPointDestination();
		
		if (!Core.isAuto() && fx == GenFx.RADIAL) {
			radialScreen(dest);
		} else if (!Core.isAuto() && fx == GenFx.RECTANGULAR) {
			rectangularScreen(dest);
		} else if (!Core.isAuto() && fx == GenFx.CIRCULAR) {
			circularScreen(dest);
		} else if (Core.isAuto() && fx == GenFx.RADIAL) {
			radialAuto(dest);
		} else if (Core.isAuto() && fx == GenFx.RECTANGULAR) {
			rectangularAuto(dest);
		} else if (Core.isAuto() && fx == GenFx.CIRCULAR) {
			circularAuto(dest);
		}

		if (!Core.isCH()) {
			genEdges(dest, Cover.edges);
		}
	}

	public static void radialScreen(ArrayList<Point> dest) {
		Canvass c = Core.canvass;
		// set min && max
		Point midPoint = new Point(c.getWidth() / 2, c.getHeight() / 2);
		int maxRad = (int) (Math.min(c.getWidth() * 0.95, c.getHeight() * 0.95) / 2);
		
		// generate points using a midpoint and radius
		for (int i = 0; i < N; i++) {
			double angle = rand.nextDouble(Math.PI * 2);
			double radius = Math.max(rand.nextInt(maxRad), rand.nextInt(maxRad));
			int x = (int) (Math.cos(angle) * radius + midPoint.x);
			int y = (int) (Math.sin(angle) * radius + midPoint.y);
			dest.add(new Point(x, y));
		}
	}

	public static void rectangularScreen(ArrayList<Point> dest) {
		int width = Core.canvass.getWidth();
		int height = Core.canvass.getHeight();
		for (int i = 0; i < N; i++) {
			int x = rand.nextInt((int) (width * 0.96));
			int y = rand.nextInt((int) (height * 0.96));
			x += width * 0.02;
			y += height * 0.02;
			dest.add(new Point(x, y));
		}
	}

	public static void circularScreen(ArrayList<Point> dest) {
		Canvass c = Core.canvass;
		Point midPoint = new Point(c.getWidth() / 2, c.getHeight() / 2);
		int radius = (int) (Math.min(c.getWidth() * 0.95, c.getHeight() * 0.95) / 2);
		
		for (int i = 0; i < N; i++) {
			double angle = rand.nextDouble(Math.PI * 2);
			int x = (int) (Math.cos(angle) * radius + midPoint.x);
			int y = (int) (Math.sin(angle) * radius + midPoint.y);
			dest.add(new Point(x, y));
		}
	}

	public static void radialAuto(ArrayList<Point> dest) {
		int halfMax = (int) (Integer.MAX_VALUE / 2.1);
		// I divide by 2.1 to make sure to avoid integer overflow
		Point midPoint = new Point(halfMax, halfMax);
		
		for (int i = 0; i < N; i++) {
			double angle = rand.nextDouble(Math.PI * 2);
			double radius = Math.max(rand.nextInt(halfMax), rand.nextInt(halfMax));
			int x = (int) (Math.cos(angle) * radius + midPoint.x);
			int y = (int) (Math.sin(angle) * radius + midPoint.y);
			dest.add(new Point(x, y));
		}
	}

	public static void rectangularAuto(ArrayList<Point> dest) {
		for (int i = 0; i < N; i++) {
			int x = rand.nextInt() & Integer.MAX_VALUE; // make positive
			int y = rand.nextInt() & Integer.MAX_VALUE;
			dest.add(new Point(x, y));
		}
	}

	public static void circularAuto(ArrayList<Point> dest) {
		int halfMax = (int) (Integer.MAX_VALUE / 2.1);
		Point midPoint = new Point(halfMax, halfMax);
		int radius = halfMax;
		
		for (int i = 0; i < N; i++) {
			double angle = rand.nextDouble(Math.PI * 2);
			int x = (int) (Math.cos(angle) * radius + midPoint.x);
			int y = (int) (Math.sin(angle) * radius + midPoint.y);
			dest.add(new Point(x, y));
		}
	}

	public static void genEdges(ArrayList<Point> vertices, ArrayList<Edge> edges) {
		edges.clear(); // first we want to wipe away any past edges
		for (Point u : vertices) {
			for (Point v : vertices) {
				if (u != v && rand.nextDouble() <= density) {
					Edge newEdge = new Edge(u, v);
					if (!Utility.containsDeep(edges, newEdge)) {
						edges.add(newEdge);
					}
				}
			}
		}
	}

	/** Increases Generator.density. Max is 1. */
	public static void densityUp() {
		if (density < 0.1) density += 0.05;
		else if (density >= 0.9) density += 0.05;
		else density += 0.1;

		if (density > 1) density = 1;
		density = Math.round(density * 100) / 100.0;
	}

	/** Decreases Generator.density. Min is 0. */
	public static void densityDown() {
		if (density <= 0.1) density -= 0.05;
		else if (density > 0.9) density -= 0.05;
		else density -= 0.1;

		if (density < 0) density = 0;
		density = Math.round(density * 100) / 100.0;
	}
	
	public static String getDensityAsString() {
		return String.format("%.02f", density);
	}
}
